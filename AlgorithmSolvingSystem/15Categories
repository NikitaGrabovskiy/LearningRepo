                                    Document Each type and subtype

1Ô∏è‚É£ Arrays & Hashing
2Ô∏è‚É£ Two Pointers
            Opposite-direction pointers (left ‚Üî right)
            Same-direction pointers (fast & slow)
            Fixed-size window (two pointers)
            Variable-size window (sliding window)
            Multiple pointers (e.g., 3Sum / N-Sum)
3Ô∏è‚É£ Sliding Window
            Fixed-size sliding window
            Variable-size (dynamic) sliding window
            Sliding window with frequency map
            Sliding window with monotonic deque
            Sliding window with at-most / at-least constraint

            üìù Sliding Window Note (Why +1)
                The window is inclusive: s[left ... right]

                Number of elements in an inclusive range is:

                    right - left + 1

                Without +1, you under-count the window size

                Under-counting allows invalid windows and gives wrong answers

                Always use:

                    windowSize = right - left + 1;

                Rule to remember:

                 Inclusive indices ‚Üí always add +1

4Ô∏è‚É£ Stack / Monotonic Stack
5Ô∏è‚É£ Binary Search

            Find , or return index where is supposed to be :

            class Solution {
                public int searchInsert(int[] nums, int target) {
                    int left = 0, right = nums.length - 1;

                    while (left <= right) {
                        int mid = left + (right - left) / 2;

                        if (nums[mid] == target) {
                            return mid;
                        } else if (nums[mid] < target) {
                            left = mid + 1;
                        } else {
                            right = mid - 1;
                        }
                    }

                    return left;
                }
            }

6Ô∏è‚É£ Linked List
7Ô∏è‚É£ Trees ‚Äì DFS / BFS
            DFS (Depth-First Search)
            Preorder traversal
            Inorder traversal
            Postorder traversal
            Recursive DFS
            Iterative DFS (using stack)

            BFS (Breadth-First Search)
            Level-order traversal
            Zigzag level-order traversal
            BFS using queue
            Multi-source BFS (tree variants)

            Notes:
                ** A binary tree is a tree data structure where each node has at most two children,
                called the left and right child.

                *** A binary tree depth search complexity is O(n) (Number of nodes) (Each node traversed once)



8Ô∏è‚É£ Backtracking
            Core idea (one sentence)
            Try a choice ‚Üí explore deeper ‚Üí if it doesn‚Äôt work, undo the choice and try the next one.

            Notes:

            *** LeetCode 78 (Subsets, classic example) ‚Äî Complexity (short)
            Time Complexity: O(n ¬∑ 2‚Åø)
            There are 2‚Åø subsets
            Each subset copy can take up to O(n)
            Space Complexity: O(2‚Åø)
            To store all subsets
            Excluding output recursion/iteration overhead

9Ô∏è‚É£ Heap / Priority Queue

            Notes:
            *** In algorithms, a stack is a LIFO data structure used for DFS and backtracking, while a heap is
            a tree-based data structure used as a priority queue to efficiently retrieve minimum or maximum elements.

            *** To use with java:

                PriorityQueue<Integer> pq =
                    new PriorityQueue<>(Collections.reverseOrder());

                Find second largest element:

                            maxHeap.poll();              // remove largest
                            int secondLargest = maxHeap.peek();



üîü Intervals
1Ô∏è‚É£1Ô∏è‚É£ Greedy
1Ô∏è‚É£2Ô∏è‚É£ Dynamic Programming
            Dynamic Programming solves problems by breaking them into overlapping
            subproblems and reusing results instead of recomputing them.
1Ô∏è‚É£3Ô∏è‚É£ Graphs
1Ô∏è‚É£4Ô∏è‚É£ Bit Manipulation
1Ô∏è‚É£5Ô∏è‚É£ Union Find